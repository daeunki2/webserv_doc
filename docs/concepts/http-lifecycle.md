---
sidebar_position: 3
---

# HTTP 요청과 응답의 흐름

## 하나의 요청은 어디서 시작되는가
HTTP 요청은
사용자가 브라우저에서 주소를 입력하거나,
버튼을 클릭하는 순간 시작된다.
하지만 서버의 관점에서 보면
이 행동은 곧바로 “화면 요청”이 아니라,
**하나의 메시지 생성**에 가깝다.

클라이언트는
자신이 원하는 동작을
정해진 형식의 요청으로 만들어
서버로 전송한다.
HTTP는 바로 이 요청 메시지의
형식을 정의한 규약이다.

## 서버에 도착한 요청은 바로 처리되지 않는다
요청이 서버에 도착했다고 해서,
곧바로 로직 처리가 시작되는 것은 아니다.

서버는 먼저
이 요청이 안전한지,
그리고 HTTP 규격에 맞게 작성되었는지를 확인한다.
과거에는 통신 장비나 시스템마다
서로 다른 형식을 사용했지만,
오늘날 웹에서는
HTTP라는 공통 규격을 사용한다.

또한 HTTP는
버전에 따라 동작 방식이 다를 수 있기 때문에,
서버는 요청을 처리하기 전에
요청의 형식과 버전을 정확히 확인해야 한다.

## 요청을 읽는다는 것의 의미
HTTP 요청은
단순한 문자열이 아니라,
구조를 가진 메시지이다.

일반적인 요청은 다음과 같은 형태를 가진다.

- 요청 라인 (method, URI, version)
- 헤더(header)
- 본문(body)

사람의 언어에 문법이 있듯,
HTTP에도 반드시 지켜야 할 규칙이 있다.
서버는 요청을 “받는 것”에서 끝나지 않고,
이 구조를 하나씩 해석하며
어떤 요청인지 이해해야 한다.

## 요청이 완성되었다는 판단
서버는 요청을 읽는 동안,
“이 요청이 언제 끝났는지”를 판단해야 한다.

## HTTP의 간단한 규칙
HTTP는 사람이 읽을 수 있는 텍스트 기반 프로토콜이며,
몇 가지 기본적인 규칙 위에서 동작한다.
이 문서에서는 webserv를 이해하는 데
필요한 최소한의 규칙만 다룬다.

1. **요청과 응답은 모두 텍스트로 이루어져 있다**  
   HTTP 메시지는 바이너리가 아니라 문자열이다.
   따라서 서버는 들어온 데이터를
   문자 단위로 읽고 해석해야 한다.

2. **요청은 순서가 있는 구조를 가진다**  
   요청은 크게 다음 순서로 구성된다.
   - 요청 라인 (method, URI, version)
   - 헤더(header)
   - 빈 줄
   - 본문(body, 선택)

   이 순서는 반드시 지켜져야 하며,
   서버는 이 구조를 기준으로 요청을 해석한다.

3. **각 줄은 `\r\n`으로 끝난다**  
   HTTP에서 한 줄의 끝은 `\r\n`으로 구분된다.
   단순한 `\n`만으로는
   요청의 경계를 정확히 판단할 수 없다.

4. **헤더의 끝은 ‘빈 줄’로 표시된다**  
   연속된 `\r\n` 한 번은
   헤더가 끝났음을 의미한다.
   이 지점 이후부터가 본문이다.

5. **본문의 길이는 헤더 정보로 판단한다**  
   본문이 있는 요청의 경우,
   서버는 헤더에 포함된 정보(Content-Length 등)를 바탕으로
   어디까지 읽어야 하는지를 판단해야 한다.

이 규칙들 덕분에 서버는
“언제 요청이 시작되고,
언제 끝났는지”를
네트워크 환경에서도 판단할 수 있다.


즉, 서버는
네트워크로 들어오는 데이터를 계속 읽으면서,
**요청이 완전히 도착했는지**를
스스로 판단해야 한다.



## 응답은 어떻게 만들어지는가
요청이 완성되면,
서버는 그 내용을 바탕으로
어떤 응답을 보낼지 결정한다.

요청한 리소스가 존재하는지,
접근이 허용되는지,
또는 오류가 발생했는지에 따라
응답의 내용은 달라진다.

이 단계에서 서버는
응답 상태 코드,
헤더,
그리고 필요한 경우 본문을 구성해
하나의 HTTP 응답 메시지를 만든다.

## 응답은 언제, 어떻게 전송되는가
응답이 만들어졌다고 해서,
즉시 전송할 수 있는 것은 아니다.

서버는
소켓이 데이터를 보낼 수 있는 상태인지 확인한 뒤,
가능한 시점에 응답을 전송한다.
응답 또한 한 번에 모두 전송되지 않을 수 있으며,
여러 번에 나누어 보내질 수도 있다.

이 과정 역시
이벤트 루프와 상태 감시에 의해 제어된다.

## 하나의 연결에서 이 과정은 반복된다
하나의 연결이 유지되는 동안,
요청과 응답의 흐름은
여러 번 반복될 수 있다.

이 때문에 서버는
“연결 하나”를 단순한 요청 처리로 보지 않고,
요청과 응답의 상태를 관리하는 대상으로 다룬다.
이것이 서버에서
클라이언트가 상태 기계처럼 동작하는 이유이다.

## 이 문서에서 다루지 않는 것
이 문서에서는 다음 내용을 다루지 않는다.

- 상태 코드 목록
- CGI나 내부 처리 로직

이 문서의 목적은
HTTP 요청과 응답이
**어떤 흐름으로 서버를 통과하는지**
전체 그림을 이해하는 데 있다.
