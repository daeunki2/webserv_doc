---
sidebar_position: 2
---

# poll과 select는 무엇이 다른가

## 서버는 어떻게 이벤트를 알게 되는가
이벤트 루프에서 서버는 끊임없이 질문을 던진다.

> “지금 반응해야 할 이벤트가 있는가?”

하지만 서버는
모든 소켓을 하나씩 직접 확인할 수는 없다.
연결이 많아질수록
이 방식은 곧 한계에 부딪힌다.

그래서 서버는
운영체제에게 이 역할을 위임한다.
“여러 소켓 중, 지금 상태가 바뀐 것이 있으면 알려달라”는 요청이다.

이 역할을 수행하는 메커니즘이
select와 poll이다.

## 상태를 감시한다는 것의 의미
서버는
“요청을 처리할까?”를 묻지 않는다.
대신 이렇게 묻는다.

- 지금 읽을 수 있는 데이터가 있는가?
- 지금 데이터를 보낼 수 있는 상태인가?

즉, 서버가 관심을 가지는 것은
행동이 아니라 **상태의 변화**이다.

select와 poll은
이 상태 변화를 감시하기 위한 도구이다.

## select의 기본 아이디어
select는
여러 소켓을 한 번에 감시하는
가장 오래된 방식 중 하나이다.

서버는
“이 소켓들 중에서
지금 읽거나 쓸 수 있는 것이 있는가?”
라고 운영체제에게 묻는다.

운영체제는
요청받은 소켓 목록을 확인한 뒤,
상태가 바뀐 소켓이 있으면
서버에게 알려준다.

이 방식은
이벤트 루프의 기본 개념을
가장 직관적으로 보여준다.

## select 방식의 한계
select는 개념적으로 단순하지만,
구조적인 한계를 가지고 있다.

서버는 매번
감시할 모든 소켓 목록을
운영체제에게 다시 전달해야 한다.
그리고 결과를 확인할 때도
전체 목록을 다시 훑어야 한다.

연결 수가 적을 때는 문제가 되지 않지만,
클라이언트 수가 많아질수록
이 방식은 점점 비효율적으로 변한다.

이 때문에 select는
작은 규모의 서버나
교육용 예제에는 적합하지만,
확장성을 고려한 서버에는 부담이 된다.

## poll의 기본 아이디어
poll은
select와 같은 문제를
조금 다른 방식으로 해결한다.

poll은
감시 대상 소켓과 관심 있는 상태를
하나의 목록으로 관리한다.
이 목록은 서버가 유지하며,
운영체제는 그 목록을 기반으로
상태 변화를 감시한다.

서버는
“이 목록 중에서 상태가 바뀐 것이 있는가?”
라고 묻고,
운영체제는
변화가 발생한 항목만 표시해 준다.

## 왜 poll이 더 자연스러운 선택이 되는가
poll은
이벤트 루프와 자연스럽게 어울린다.

- 감시 대상이 명확한 목록으로 관리되고
- 각 소켓의 상태가 독립적으로 표현되며
- 클라이언트 수가 늘어나도 구조가 깨지지 않는다

webserv 과제에서
여러 클라이언트와 연결을 관리해야 하는 상황에서는,
poll이
구조적으로 더 직관적이고
설계 의도를 드러내기 좋은 선택이 된다.

poll은
“지금 반응해야 할 이벤트만 골라낸다”는
이벤트 루프의 철학을
가장 잘 반영한 도구이다.

## 이 문서에서 다루지 않는 것
이 문서에서는 다음 내용을 다루지 않는다.

- epoll, kqueue와 같은 고급 메커니즘
- 시스템 콜의 실제 시그니처
- 성능 수치 비교나 벤치마크

이 문서의 목적은
API를 외우는 것이 아니라,
**왜 이런 도구가 필요한지**를 이해하는 데 있다.
