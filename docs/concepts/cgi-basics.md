---
sidebar_position: 4
---

# CGI란 무엇인가

## 정적 파일과 동적 응답의 차이
지금까지 여러 예시를 사용해 설명했지만,
우리가 구현하는 webserv는
기본적으로 **정적 웹 서버**이다.
이 점에서 일반적인 “동적 서버”와는
결이 다르다.

동적 서버의 예로
메이플스토리를 다시 떠올려 보자.
사용자가 사냥을 하거나 무기를 강화하면,
그 결과는 서버에 저장되고
다시 클라이언트로 반영된다.
사용자는 언제 어디서 접속하든
마지막 상태에서 게임을 이어갈 수 있다.

반면 정적 서버는 다르다.
사용자가 무엇을 하든
서버 자체의 상태는 변하지 않는다.
당신이 주황버섯을 천 마리 잡았더라도,
다시 접속하면 캐릭터는 여전히 뉴비이다.

정적 웹 서버의 역할은 단순하다.
서버의 특정 디렉토리에 있는 파일을
읽어서 보여주고,
필요하다면 업로드하거나 삭제하는 정도이다.
이 역할은 도서관 사서의 업무와 비슷하다.

## 서버가 모든 요청을 직접 처리할 수는 없다
정적 웹 서버는
요청에 따라 자료를 꺼내 주거나,
보관하거나,
삭제하는 역할을 수행한다.

하지만 만약 도서관 사서에게
그 역할의 범위를 벗어나는 요청을 한다면
어떤 일이 벌어질까?
사서는 직접 처리하지 않고,
다른 담당자에게 안내하거나
외부 도움을 요청할 것이다.

웹 서버도 마찬가지다.
모든 요청을
서버 내부 로직으로 직접 처리하려고 하면,
서버의 책임은 지나치게 커지고
구조는 빠르게 복잡해진다.

## CGI는 서버의 기능이 아니라 확장이다
CGI는
서버의 내부 기능이 아니다.
서버가 필요에 따라 호출하는
**외부 프로그램**이다.

정적 웹 서버가
기본적인 역할만 수행하도록 두고,
추가적인 처리나 계산이 필요한 경우에만
CGI를 통해 기능을 확장한다.
이렇게 역할을 분리함으로써
서버는 단순함을 유지할 수 있다.

## 왜 CGI는 별도의 프로세스로 실행되는가
CGI는
서버와 동일한 프로세스 안에서 실행되지 않는다.
대신 별도의 프로세스로 실행된다.

이는 서버를 보호하기 위한 선택이다.
CGI 프로그램이 오래 걸리거나,
오류를 일으키더라도
서버 전체가 영향을 받지 않도록 하기 위함이다.

도서관 사서가
직접 처리하지 않고
다른 직원을 부르는 것과 같다.
서버는 요청을 넘기고,
CGI는 독립적으로 자신의 작업을 수행한다.

## 서버와 CGI는 어떻게 통신하는가
서버와 CGI는
직접 메모리를 공유하지 않는다.
대신 **표준 입력과 출력**을 통해 통신한다.

서버는
클라이언트의 요청 내용을
CGI의 입력으로 전달하고,
CGI는 처리 결과를
출력으로 돌려준다.
이 통신은 파이프와 같은
단방향 통로를 통해 이루어진다.

이 구조 덕분에
서버와 CGI는 느슨하게 결합된 상태를 유지한다.

## CGI가 이벤트 루프에 던지는 문제
CGI는
서버 내부 로직과 달리
별도의 실행 흐름을 가진다.
즉, 새로운 프로세스가 하나 더 생긴다.

요청의 크기가 크거나,
처리 시간이 긴 경우,
CGI는 아직 실행 중인데
서버는 이벤트 루프에 따라
다른 클라이언트의 요청으로 넘어가게 된다.

이때 서버는
CGI의 진행 상태를
어떻게 관리해야 할지라는
새로운 문제에 직면한다.
이 문제를 제대로 다루지 않으면,
클라이언트 연결이 불안정해지거나
서버의 흐름이 깨질 수 있다.

이 지점에서
CGI와 이벤트 루프의 관계는
단순하지 않은 문제가 된다.
