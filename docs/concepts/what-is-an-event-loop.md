---
sidebar_position: 1
---

# 이벤트 루프란 무엇인가

## 동시에 처리한다는 말의 오해
하나의 서버가 다수의 클라이언트와 통신한다고 하면,
흔히 “한 번에 여러 개를 동시에 처리한다”고 생각하기 쉽다.
마치 서버가 여러 작업을 병렬로 실행하는 것처럼 느껴지기 때문이다.

하지만 실제로 서버는
한 순간에 하나의 작업만 처리한다.
서버는 컴퓨터 위에서 실행되는 프로그램이며,
동시에 여러 생각을 할 수 있는 존재는 아니다.

걱정할 필요는 없다.
서버는 우리가 체감하지 못할 만큼 빠르게
작업을 전환하며 처리한다.
이 빠른 전환 때문에
우리는 동시에 처리되는 것처럼 느끼게 된다.

## 서버는 왜 동시에 처리할 수 없나?
서버가 동시에 여러 요청을 처리하지 못하는 이유는
서버가 느리거나 성능이 부족해서가 아니다.
그 이유는 서버가 **하나의 실행 흐름을 가진 프로그램**이기 때문이다.

서버 프로그램은 CPU 위에서 실행되며,
하나의 실행 흐름은 한 순간에 하나의 작업만 수행할 수 있다.
어떤 요청을 처리하고 있다면,
그 처리 흐름이 끝나기 전까지
다른 요청을 같은 흐름에서 동시에 처리할 수 없다.

요청을 처리한다는 것은 단순한 한 동작이 아니라,
데이터를 읽고, 해석하고, 로직을 수행하고,
응답을 만들어 다시 보내는
연속된 작업들의 묶음이다.
이 과정이 진행되는 동안
프로그램의 실행 흐름은 그 요청에 묶이게 된다.

따라서 서버가 “한 번에 하나만 처리한다”는 말은
성능의 한계를 의미하는 것이 아니라,
**프로그램의 실행 방식에서 비롯된 구조적 특성**을 의미한다.

## 한번에 하나의 클라이언트를 처리하는 비효율
프랑스에서 행정 처리를 해본 적이 있는가?

내 앞에 있는 피에르 씨가 직원과 잡담을 시작하면,
나는 그의 일이 끝날 때까지 아무것도 하지 못한 채 기다려야 한다.
그 시간이 길어질수록 불편함과 비효율은 커진다.

서버에서도 같은 일이 벌어진다.
하나의 요청에서 “기다림”이 발생하면,
그 시간 동안 서버는 다른 요청을 처리하지 못한다.

하지만 우리가 사용하는 게임이나 웹사이트에서는
이런 지연을 거의 느끼지 않는다.
그렇다면 이 문제는 어떻게 해결된 것일까?

그 해답이 바로 이벤트 루프이다.


## 이벤트라는 관점으로 바라보기
피에르 씨의 방문,
나의 방문,
서류 제출,
서류 요청은 모두 하나의 **사건**이다.
즉, 이벤트이다.

만약 직원이
특정 사람에게 묶이지 않고,
이벤트가 발생할 때만 반응한다면
상황은 달라진다.
잡담에는 반응하지 않고,
새로운 요청이 생겼을 때만 행동하면
전체 흐름은 훨씬 효율적으로 바뀐다.

## 이벤트 루프의 기본 아이디어
서버를 직원,
클라이언트를 시민이라고 생각해 보자.

시민들이 각자 서류를 작성하고 있는 동안,
직원이 굳이 계속 지켜보고 있을 필요는 없다.
새로운 서류를 요청하거나,
작성된 서류를 제출하려는 순간에만
직원이 반응하면 된다.

이처럼 서버는
“항상 처리하려고 애쓰는 것”이 아니라,
**이벤트가 발생했을 때만 반응하는 구조**를 가진다.
이 반복되는 감시와 반응의 흐름이
이벤트 루프이다.

## 서버는 무엇을 반복해서 보고 있는가
서버가 반복해서 확인하는 것은
클라이언트 자체가 아니라,
**클라이언트로부터 발생한 요청의 상태**이다.

읽을 수 있는 요청이 있는지,
응답을 보낼 준비가 되었는지와 같은
상태 변화가 서버의 판단 기준이 된다.

## 이 문서에서 다루지 않는 것
이 문서에서는 다음 내용을 다루지 않는다.

- poll, select와 같은 구체적인 메커니즘
- 이벤트를 감시하는 구현 방식
- 실제 코드 구조

이제 남은 질문은 하나다.  
이 이벤트의 상태를  
**누가, 어떻게 서버에게 알려주는가?**
