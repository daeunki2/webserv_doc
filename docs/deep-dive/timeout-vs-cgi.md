---
sidebar_position: 3
---

# timeout과 CGI 실행은 어떻게 충돌하는가

## timeout은 무엇을 기준으로 판단되는가
webserv에서 말하는 timeout은
“요청 처리 시간이 길다”가 아니라,
**클라이언트 연결이 idle 상태로 방치되었는가**를 기준으로 판단한다.

구체적으로 서버는 tick 기반으로 시간을 누적하며,
각 클라이언트의 `last_activity_tick`과 현재 tick의 차이를 비교해
idle timeout 여부를 검사한다.

즉, timeout의 기준은
“서버가 바쁜가”가 아니라
“이 연결이 활동이 있었는가”이다.

## 서버 관점에서의 timeout과 클라이언트 관점의 차이
서버 관점에서 timeout은
클라이언트가 일정 시간 동안
요청(또는 추가 데이터)을 보내지 않는 상태를 의미한다.

반면 클라이언트 관점에서 timeout은 보통
서버 응답이 늦어지거나 멈춘 것처럼 느껴지는 상황을 말한다.

이 둘을 혼동하면,
“응답이 늦으니 timeout” 같은 잘못된 정책이 생길 수 있다.
서버의 timeout은 “idle”을 다루는 정책이어야 한다.

## CGI 실행 중에도 timeout은 계속 흘러간다(처럼 보일 수 있다)
겉보기에는 CGI가 오래 걸리면
서버 입장에서 “클라이언트 활동이 없다”로 보일 수 있다.
그래서 단순한 설계에서는
CGI 실행 중 idle timeout이 발생하는 문제가 생기곤 한다.

하지만 webserv에서 이 문제를 그대로 두면,
정상적으로 긴 CGI 요청도
서버가 임의로 끊어버리는 상황이 발생한다.

## webserv는 이 충돌을 어떻게 해결하는가
이 구현에서는
CGI 실행 중에는 idle timeout을 검사하지 않는다.

서버의 idle timeout 검사 루틴은,
다음 상태의 클라이언트는 건너뛴다.

- CGI가 활성 상태인 경우
- 응답을 전송 중이며 아직 보낼 바이트가 남아있는 경우

즉, “서버가 해야 할 일이 진행 중인 연결”은
idle로 간주하지 않는다.
이 정책은 CGI를 예외 처리하는 것이 아니라,
idle timeout의 의미를 정확히 정의한 결과다.

## timeout을 CGI 기준으로 리셋하면 생기는 문제
CGI를 이유로 timeout을 “리셋”하는 방식은
겉보기에는 비슷해 보이지만 기준이 흐려진다.

- CGI가 길어질 때마다 timeout이 연장되면
  연결이 비정상적으로 오래 유지될 수 있고,
- 서버가 어떤 기준으로 연결을 정리하는지 불명확해진다.

이 구현은 “리셋”이 아니라
**idle timeout 검사 대상에서 제외**하는 방식으로
기준을 더 명확히 만든다.

## CGI를 이유로 timeout을 무시하면 생기는 문제
CGI 중 timeout을 무시하는 정책은 필요하지만,
“무조건 무시”는 또 다른 리스크를 만든다.

예를 들어 CGI가 비정상적으로 멈추거나,
출력이 나오지 않거나,
프로세스가 종료되지 않는 경우가 생길 수 있다.
이 경우 서버는
idle timeout이 아닌 다른 기준(예: abort/정리 시나리오)으로
프로세스를 종료하고 FD를 정리해야 한다.

즉, CGI 중 timeout을 건너뛰는 대신,
abort 정책이 반드시 함께 설계되어야 한다.

## timeout과 CGI를 분리해서 관리한다는 의미
정리하면 이 구현의 철학은 단순하다.

- timeout은 “클라이언트 연결의 idle”을 다룬다
- CGI는 “서버 내부 작업”이며 idle timeout의 판단 기준이 아니다
- CGI/응답 전송처럼 서버가 진행 중인 작업이 있다면
  그 연결은 idle로 보지 않는다

따라서 timeout과 CGI는 “충돌”하는 것이 아니라,
서로 다른 기준으로 관리된다.

## webserv에서 선택한 timeout 정책
이 webserv의 timeout 정책은 다음과 같다.

- idle timeout은 `last_activity_tick` 기반으로 판단한다
- 단, 아래 상태에서는 idle timeout 검사를 건너뛴다
  - CGI 활성 상태
  - 응답 전송 중이며 남은 바이트가 있는 상태
- CGI가 비정상 상태가 되는 경우는
  timeout이 아니라 abort/정리 정책으로 처리한다

이 정책 덕분에
정상적으로 긴 CGI 요청과 큰 응답 전송도 안정적으로 처리하면서,
정말 idle인 연결만 정리할 수 있다.
