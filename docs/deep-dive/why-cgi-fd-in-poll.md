---
sidebar_position: 1
---


# 왜 CGI의 파일 디스크립터도 poll로 관리해야 하는가

## CGI는 서버의 이벤트 루프 밖에서 실행된다
앞서 살펴보았듯이 CGI는
서버와는 별도의 프로세스로 실행된다.
이 프로세스가
얼마나 많은 자원을 사용할지,
얼마의 시간이 걸릴지는
서버가 미리 알 수 없다.

문제는 여기서 발생한다.
서버는 이벤트 기반 루프를 돌고 있지만,
CGI는 그 루프 **밖에서** 실행된다.
즉, CGI는
서버의 제어 흐름과 직접적으로 연결되어 있지 않다.

## 서버는 CGI의 진행 상황을 직접 알 수 없다
서버는 CGI 프로세스를 실행시킬 수는 있지만,
그 이후의 진행 상황을
직접 관찰할 수는 없다.

CGI가 아직 실행 중인지,
이미 출력을 준비했는지,
아니면 종료되었는지는
서버 입장에서 자동으로 알 수 있는 정보가 아니다.
서버는 단순히
“실행했다”는 사실만 알고 있을 뿐이다.

따라서 CGI의 상태 변화를
명시적으로 감지할 수단이 필요하다.

## CGI와 서버 사이에도 입출력이 존재한다
CGI가 별도의 프로세스라고 해도,
서버와 완전히 단절된 것은 아니다.
서버와 CGI 사이에는
표준 입력과 표준 출력이라는
명확한 통신 경로가 존재한다.

서버는
클라이언트로부터 받은 요청을
CGI의 입력으로 전달하고,
CGI는 처리 결과를
출력으로 돌려준다.
이 입출력 통로는
파이프를 통해 연결되며,
서버 입장에서는
또 하나의 파일 디스크립터로 보인다.

## CGI의 출력은 언제 준비되는가
CGI의 출력은
즉시 준비될 수도 있고,
오랜 시간이 지난 후에야
나올 수도 있다.

서버가 CGI의 출력을 읽으려고 할 때
아직 데이터가 준비되지 않았다면,
그 시점에서 읽기 작업은
서버를 멈추게 만들 수 있다.
즉, CGI는
다시 한 번 “기다림”의 문제를 서버로 가져온다.

## poll로 관리하지 않으면 어떤 문제가 생길까
CGI의 파일 디스크립터를
이벤트 루프에서 관리하지 않는다면,
서버는 두 가지 선택지 중 하나를 가지게 된다.

- 데이터를 확인하기 위해 무작정 읽는다  
- 데이터가 나올 때까지 기다린다  

첫 번째 경우에는
아직 준비되지 않은 데이터를 놓칠 수 있고,
두 번째 경우에는
서버 전체가 멈출 위험이 있다.

어느 쪽이든,
이벤트 기반 서버의 구조와는 맞지 않는다.

## CGI FD를 이벤트 루프에 포함시킨다는 의미
CGI의 파일 디스크립터를
poll에 등록한다는 것은,
CGI를 특별한 예외로 취급하지 않겠다는 의미이다.

CGI의 출력이 준비되었는지,
더 이상 출력이 없는지(EOF),
이 모든 상태 변화를
소켓과 동일한 이벤트로 다룬다.

즉, 파이프에서 EOF가 감지되는 순간도
서버에게는 하나의 이벤트가 된다.

## 이 설계가 webserv에서 가지는 의미
이 설계는 구현을 단순하게 만들지는 않는다.
오히려
관리해야 할 파일 디스크립터와
상태는 더 늘어난다.

하지만 그 대가로,
서버는 CGI가 포함된 상황에서도
이벤트 루프를 멈추지 않고,
큰 요청이나 느린 처리도
안정적으로 다룰 수 있게 된다.

이것이
CGI의 파일 디스크립터를
이벤트 루프에 포함시켜야 하는
구조적인 이유이다.
