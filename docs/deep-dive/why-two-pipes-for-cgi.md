---
sidebar_position: 2
---

# 왜 CGI에는 파이프가 두 개 필요한가

## 서버와 CGI 사이에는 두 방향의 통신이 필요하다
CGI는
서버가 실행시키는 별도의 프로세스이다.
따라서 서버와 CGI 사이에는
명확한 통신이 필요하다.

이 통신은 한 방향으로만 이루어지지 않는다.
서버는 CGI에게 요청 데이터를 전달해야 하고,
CGI는 서버에게 처리 결과를 돌려주어야 한다.

즉, 통신은 다음 두 방향을 모두 포함한다.

- 서버 → CGI  
- CGI → 서버  

이 두 흐름은 성격이 다르며,
각각 독립적으로 관리되어야 한다.

## 요청과 응답은 같은 흐름이 아니다
서버에서 CGI로 전달되는 요청과,
CGI에서 서버로 전달되는 응답은
시간적으로도, 의미적으로도 다른 흐름이다.

요청은
CGI가 실행되기 직전 또는 실행 초기에 전달되며,
응답은
CGI의 처리가 진행된 이후에 생성된다.

이 두 흐름을 하나로 취급하면,
언제 무엇을 보내고 받아야 하는지가
불명확해진다.

## 하나의 파이프로는 무엇이 부족한가
파이프는 기본적으로
**단방향 통신**을 제공한다.
한쪽에서는 쓰고,
다른 쪽에서는 읽기만 할 수 있다.

물론 `dup2`와 같은 함수를 활용해
입출력을 재지정할 수는 있다.
하지만 이 방식으로
하나의 파이프를 양방향처럼 사용하는 것은
역할과 책임을 흐리게 만든다.

통신의 방향이 섞이는 순간,
디버깅과 상태 관리의 복잡도는 급격히 증가한다.

## 표준 입력과 표준 출력이라는 분리된 역할
CGI는
표준 입력(stdin)과
표준 출력(stdout)을 기준으로 동작한다.

서버는
클라이언트로부터 받은 요청을
CGI의 표준 입력으로 전달하고,
CGI는 처리 결과를
표준 출력으로 내보낸다.

이 구조는
입력과 출력의 역할을
명확히 분리한다는 점에서
매우 중요한 의미를 가진다.

## 파이프 하나로 양방향 통신을 시도하면 생기는 문제
하나의 파이프로
요청과 응답을 모두 처리하려고 하면,
다음과 같은 문제가 발생할 수 있다.

- 읽기와 쓰기의 경계가 불분명해진다  
- 어느 시점에 누가 기다려야 하는지 알기 어렵다  
- 잘못된 순서로 접근하면 데드락이 발생할 수 있다  

특히 이벤트 기반 서버에서는,
이러한 불확실성이
서버 전체 흐름을 망가뜨릴 위험이 있다.

## 두 개의 파이프가 만들어내는 명확한 책임 분리
두 개의 파이프를 사용하면,
통신의 역할은 명확해진다.

- 하나의 파이프: 서버 → CGI (입력 전달)
- 다른 하나의 파이프: CGI → 서버 (출력 수신)

각 파이프는
자신의 방향과 목적만을 가진다.
이 덕분에 서버는
언제 쓰고,
언제 읽어야 하는지를
명확히 판단할 수 있다.

## 이 구조가 이벤트 루프와 잘 맞는 이유
이벤트 루프는
“지금 읽을 수 있는가”,
“지금 쓸 수 있는가”와 같은
상태를 기준으로 동작한다.

입력용 파이프와 출력용 파이프가 분리되어 있으면,
서버는 각각을
독립적인 파일 디스크립터로 감시할 수 있다.

이 구조는
CGI를 소켓과 동일한 이벤트 단위로 취급하게 만들며,
이벤트 기반 서버의 철학과 정확히 맞아떨어진다.

## 이 설계가 webserv에서 가지는 의미
두 개의 파이프를 사용하는 설계는
구현 난이도를 높인다.
관리해야 할 파일 디스크립터와
상태도 늘어난다.

하지만 그 대가로,
서버는 CGI가 포함된 상황에서도
명확한 통신 구조를 유지할 수 있고,
복잡한 요청을 안정적으로 처리할 수 있다.

이것이
CGI에 두 개의 파이프가 필요한
구조적인 이유이다.
