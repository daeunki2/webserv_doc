---
sidebar_position: 5
---

# 포트, 소켓, 그리고 연결

## 서버는 어디서 요청을 받는가
이제 우리는 서버가 하나의 프로그램이며,
클라이언트와 서버가 웹을 통해 요청과 응답을 주고받는다는 것을 알고 있다.
그렇다면 다음 질문은 자연스럽다.

요청은 서버의 **어디로** 도착하는 것일까?  
그리고 서버는 **어디에서** 그 요청을 기다리고 있을까?

이 질문에 답하기 위해,
먼저 네트워크에서 사용되는 주소 개념부터 살펴볼 필요가 있다.

## IP 주소와 포트
IP 주소는 네트워크 상에서
어느 컴퓨터인지를 식별하기 위한 주소이다.
클라이언트는 IP 주소를 통해
요청을 보낼 컴퓨터까지 도달할 수 있다.

하지만 하나의 컴퓨터에는
여러 프로그램이 동시에 실행되고 있다.
이때 **포트(port)**는
그 컴퓨터 안에서
“어느 프로그램과 통신할 것인지”를 구분하기 위한 번호이다.

즉,
- IP 주소는 **어느 컴퓨터인지**
- 포트는 **그 컴퓨터 안의 어느 프로그램인지**

를 나타낸다.

## 포트는 열려 있지만, 연결은 아직 없다
서버는 요청을 받기 위해
특정 포트를 열고 대기 상태에 들어간다.
이 상태에서 서버는
“이 포트로 요청이 오면 처리하겠다”라고 준비만 하고 있다.

중요한 점은,
이 단계에서는 아직 **어떤 클라이언트와도 연결되어 있지 않다**는 것이다.
포트는 열려 있지만,
실제 통신이 이루어지는 연결은 아직 만들어지지 않았다.

## 소켓(Socket)이란 무엇인가
소켓은
클라이언트와 서버 사이에서
실제로 데이터를 주고받기 위한 **통신 통로**이다.

운영체제의 관점에서 보면,
소켓은 하나의 자원이며
리눅스에서는 파일과 마찬가지로
파일 디스크립터(fd)로 관리된다.

하지만 중요한 것은 구현 방식이 아니라 역할이다.
소켓은
“이 클라이언트와 이 서버 사이의 통신을 담당하는 객체”이다.

## 연결(Connection)은 언제 만들어지는가
클라이언트가 서버의 포트로 접속을 시도하면,
운영체제는 그 요청을 받아
서버와 클라이언트 사이에
새로운 연결을 생성한다.

이때 서버는
기존에 열어 두었던 포트와는 별도로,
**해당 클라이언트 전용의 소켓**을 하나 더 얻게 된다.
이 소켓을 통해서만
그 클라이언트와의 통신이 이루어진다.

즉, 연결은
서버가 포트를 열었을 때가 아니라,
**클라이언트가 접속했을 때** 만들어진다.

## 왜 서버에는 소켓이 여러 개 생길까
서버는 하나의 프로그램이지만,
동시에 여러 클라이언트와 통신해야 한다.

각 클라이언트는
서버와 독립된 연결을 가지며,
이 연결마다 별도의 소켓이 생성된다.
그 결과 서버 내부에는
여러 개의 소켓이 동시에 존재하게 된다.

이제 새로운 문제가 등장한다.
서버는 이 많은 소켓을
어떻게 동시에 관리할 수 있을까?

## 이 문서에서 다루지 않는 것
이 문서에서는 다음 내용을 다루지 않는다.

- 여러 소켓을 동시에 처리하는 방법
- poll, select 같은 이벤트 처리 방식
- 파일 디스크립터를 어떻게 감시하는지

이 질문에 대한 답은
다음 문서에서 다룬다.
