---
sidebar_position: 1
---

# curl-strategy.md

## 1. 이 문서의 목적

프로젝트 초기에 나는  
**서버가 제대로 동작하는지 확인하려면 반드시 브라우저로 접속해야 한다고 생각했다.**

그 결과, 요청 하나하나를 명확히 분리해서 확인하지 못했고,  
모듈 단위 테스트 없이 프로젝트를 급하게 진행하게 되었다.

이 문서는 나와 같은 실수를 반복하지 않기를 바라는 마음으로,  
**curl이라는 도구의 존재 이유와 기본적인 사용법**,  
그리고 **이 명령어로 무엇을 검증할 수 있는지**를 정리한 것이다.

본 문서는 다음 순서로 구성된다.

1. curl 명령어의 기본 개념과 사용 목적  
2. 실제 테스트에 사용한 명령어와 옵션 설명  
3. 해당 테스트를 통해 무엇을 검증할 수 있는지  

---

## 2. curl이란 무엇인가

`curl`은 커맨드라인 환경에서 HTTP 요청을 전송할 수 있는 도구이다.  
웹 브라우저처럼 서버에 요청을 보내지만,  
**테스트 관점에서는 브라우저와 역할이 명확히 다르다.**

웹 브라우저는 사용자를 위한 도구이다.  
페이지를 렌더링하고, 내부적으로 여러 요청을 자동으로 전송하며,  
요청과 응답의 세부 내용을 사용자가 명확히 제어하기 어렵다.

반면 curl은  
**HTTP 요청 그 자체를 직접 만들고 전송하기 위한 도구**이다.

curl을 사용하면 다음과 같은 점을 명확히 제어할 수 있다.

- 어떤 HTTP method를 사용하는지
- 어떤 header를 포함하는지
- request body가 있는지, 있다면 그 크기와 형태
- 서버가 반환한 정확한 status code와 header

이러한 이유로 curl은  
**“이 서버가 HTTP 서버로서 올바르게 동작하는가”**를  
가장 직접적으로 검증할 수 있는 도구이다.

특히 webserv 과제에서는  
브라우저로는 확인하기 어려운 다음과 같은 항목들이 중요하다.

- `405 Method Not Allowed`가 정확히 반환되는지
- `HEAD` 요청에 대해 body가 없는지
- 대용량 요청에서 `413 Payload Too Large`가 발생하는지
- 서버가 예상하지 않은 요청에 대해 안정적으로 동작하는지

curl은 이러한 항목을  
**요청 단위로, 반복 가능하게, 의도적으로 테스트할 수 있게 해준다.**

따라서 curl은 단순한 “요청 도구”가 아니라,  
webserv 프로젝트에서 **서버 구현을 검증하기 위한 핵심 테스트 도구**이다.


### 2.1 curl과 모듈 단위 테스트

curl이 중요한 또 하나의 이유는  
**브라우저를 통하지 않고도 HTTP 요청을 직접 보낼 수 있다는 점**이다.

웹 브라우저를 사용하면  
요청은 항상 “페이지 단위”로 전송되고,  
요청 생성 과정과 서버 응답 처리가 내부적으로 감춰진다.

반면 curl은  
**하나의 HTTP 요청을 의도적으로 만들어 서버에 전달**할 수 있다.

이 점은 webserv 프로젝트에서  
다음과 같은 방식의 **모듈 단위 테스트**를 가능하게 한다.

- 요청 라인(request line)이 올바르게 파싱되는지
- header가 정상적으로 분리되는지
- body 유무에 따라 파싱 흐름이 달라지는지
- method / path / version이 정확히 해석되는지

예를 들어, curl로 요청을 하나 보내고  
그 요청이 서버 내부에서

**accept → read → parse → validate → respond**


의 흐름을 어떻게 타는지를 추적하면,  
**Request 파싱 로직을 독립적으로 검증**할 수 있다.

이는 브라우저 기반 테스트로는 거의 불가능하다.

curl을 사용하면 다음과 같은 방식의 테스트가 가능해진다.

- 요청 하나만 보내고 파싱 결과를 로그로 확인
- body 없는 요청 / body 있는 요청 비교
- 잘못된 요청을 보내고 어디서 reject 되는지 확인

즉, curl은 단순히 “요청을 보내는 도구”가 아니라,  
**서버 내부 모듈(Request parsing, validation, routing)을  
의도적으로 자극하기 위한 테스트 도구**로 사용할 수 있다.

이러한 이유로 본 프로젝트에서는  
브라우저 테스트 이전 단계에서  
curl을 이용한 요청 단위 테스트를 우선적으로 수행하였다.

## 2.2 curl 명령어의 기본 구조

curl 명령어는 기본적으로 다음과 같은 형태를 가진다.

```bash
curl [옵션] <URL>
```

여기서  `` `<URL>` ``은
요청을 보낼 서버의 주소를 의미한다.

URL 구성 요소 설명
다음은 실제로 가장 많이 사용하는 형태의 예시이다.

```bash
curl http://127.0.0.1:8080/
```

이 명령어는 다음 요소들로 구성되어 있다.

http://

사용할 프로토콜을 의미한다.
webserv 프로젝트에서는 http를 사용한다.

127.0.0.1

서버 주소를 의미하며,
로컬에서 실행 중인 서버(localhost)를 가리킨다.

:8080

서버가 listening 중인 포트 번호이다.
설정 파일에서 지정한 포트와 일치해야 한다.

/
서버에 요청하는 경로(path)이다.
루트 디렉토리를 의미한다.

즉, 이 한 줄의 명령어는
**“로컬에서 실행 중인 서버의 8080번 포트로
루트 경로에 대한 GET 요청을 보낸다”**는 뜻이다.

옵션이 없는 경우의 기본 동작
아무 옵션도 지정하지 않고 curl을 실행하면,
curl은 다음과 같이 동작한다.

GET method를 사용하여 요청을 보내고

request body 없이 요청을 전송하며

response body만을 출력한다

따라서 이 형태의 curl 명령어는
서버가 정상적으로 동작하는지 가장 간단히 확인하는 용도로 사용된다.

이 기본 구조를 이해하는 것이
이후 모든 curl 기반 테스트의 출발점이다.

---

## 3. curl을 이용한 요청 단위 테스트 (모듈 테스트 관점)

앞에서 curl의 개념과 기본 사용법을 살펴보았다.  
이제부터는 이 명령어를 이용해 webserv 서버의 동작을  
**요청 단위, 모듈 단위로 어떻게 테스트할 수 있는지**를 설명한다.

webserv 프로젝트에서 하나의 HTTP 요청은  
대략 다음과 같은 흐름으로 처리된다.

**accept → read → parse → validate → build response → write**

curl을 사용하면,  
이 흐름을 **하나의 요청 단위로 의도적으로 자극**할 수 있으며,  
각 단계가 올바르게 동작하는지를 독립적으로 확인할 수 있다.

---

### 3.1 가장 단순한 요청: Request Line 테스트

```bash
curl http://127.0.0.1:8080/
```
이 명령어는 서버로 가장 기본적인 형태의 요청을 전송한다.
내부적으로는 다음과 같은 request line이 만들어진다.

```bash
GET / HTTP/1.1
```
(실제 요청에는 Host 헤더 등이 함께 포함된다)

이 테스트는 Request Line 파싱 단계를 검증하기 위한 것이다.

확인할 수 있는 항목은 다음과 같다.

서버가 요청을 정상적으로 accept 하는지

method(GET), path(/), version(HTTP/1.1)이 올바르게 분리되는지

파싱 이후 정상적인 응답 처리 흐름으로 진입하는지

즉, 이 한 줄의 curl 명령어는
Request 파싱 로직의 가장 첫 단계를 검증하는 테스트이다.

### 3.2 -i 옵션을 이용한 Response 생성 확인


```bash
curl -i http://127.0.0.1:8080/
```

-i 옵션은
서버가 생성한 HTTP response header를 body와 함께 출력하도록 한다.

이를 통해 다음과 같은 정보를 직접 확인할 수 있다.

HTTP status code (200 OK)

Content-Length

Connection 헤더 값

header와 body의 구분이 올바른지

이 테스트는
요청 파싱 이후 Response 생성 단계가 정상적으로 동작하는지를
확인하기 위한 것이다.

### 3.3 Method를 명시적으로 지정하기: -X 옵션

curl에서는 -X 옵션을 사용해
요청 method를 명시적으로 지정할 수 있다.

```bash
curl -i -X GET  http://127.0.0.1:8080/
curl -i -X HEAD http://127.0.0.1:8080/
```

이 테스트를 통해 다음을 검증할 수 있다.

method 문자열이 정확히 파싱되는지

허용된 method인지 판단하는 로직이 정상 동작하는지

method에 따라 response body 처리 방식이 달라지는지

특히 HEAD 요청은
GET과 동일한 처리 흐름을 타되
response body만 제거해야 하므로,
Response 생성 로직을 검증하기에 매우 중요하다.

### 3.4 curl을 이용한 모듈 단위 테스트의 의미

curl을 사용하면
하나의 요청을 보낸 뒤 서버 내부에서 그 요청이

accept
 → read
 → parse
 → validate
 → build response
 → write


의 흐름을 어떻게 타는지를
의도적으로 관찰할 수 있다.

예를 들어 다음과 같은 테스트가 가능하다.

정상 요청이 parse 단계까지 도달하는지

잘못된 요청이 validate 단계에서 거부되는지

body 유무에 따라 다른 파싱 경로를 타는지

이러한 테스트는 브라우저 기반 테스트로는 거의 불가능하며,
curl을 사용할 때 비로소 명확하게 수행할 수 있다.

따라서 curl은 단순한 요청 전송 도구가 아니라,
webserv 서버의 내부 모듈(Request 파싱, 검증, 응답 생성)을
요청 단위로 검증하기 위한 핵심 테스트 도구이다.

## 4. 해볼만한 테스트

```bash
# 기본 요청
curl -v http://127.0.0.0:8181/

# 헤더 확인
curl -i http://127.0.0.0:8181/

# 허용되지 않은 메서드
curl -i -X POST -H "Content-Length: 0" http://127.0.0.0:8181/
curl -i -X apple http://127.0.0.0:8181/

# post
echo "HELLO WEBSERV" > test.txt

curl -v -X POST \
  -F "file=@test.txt" \
  http://127.0.0.0:8181/upload

#delete
curl -v -X DELETE \
  http://127.0.0.0:8181/upload/test.txt

# try to delete non exist file
curl -v -X DELETE \
  http://127.0.0.0:8181/upload/nope.txt



```
